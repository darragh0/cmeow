from __future__ import annotations

from sys import exit as sexit
from sys import stderr, stdout
from typing import TYPE_CHECKING, TextIO

from colorama import Fore, Style

if TYPE_CHECKING:
    from cmeow.util._errors import ExitCode


def _parse_style(txt: str) -> str:  # noqa: C901
    """Apply color and style (bold/dim) to text.

    Generated by Claude 3.7 Sonnet
    """

    color_map = {
        "blk": Fore.BLACK,
        "red": Fore.RED,
        "grn": Fore.GREEN,
        "ylw": Fore.YELLOW,
        "blu": Fore.BLUE,
        "mag": Fore.MAGENTA,
        "cyn": Fore.CYAN,
        "wht": Fore.WHITE,
    }
    style_map = {
        "*": Style.BRIGHT,
        "$": Style.DIM,
    }

    # Process style markers first
    i = 0
    while i < len(txt):
        for marker, style in style_map.items():
            if i < len(txt) and txt[i] == marker:
                next_marker = txt.find(marker, i + 1)
                if next_marker != -1:
                    styled_content = txt[i + 1 : next_marker]
                    # Process the styled content recursively
                    processed_content = _parse_style(styled_content)
                    txt = txt[:i] + style + processed_content + Style.NORMAL + txt[next_marker + 1 :]
                    # Reset i to process from the beginning with the updated text
                    i = 0
                    break
        else:
            i += 1

    # Process color tags
    result = []
    i = 0
    while i < len(txt):
        # Handle escape sequences
        if i < len(txt) - 1 and txt[i : i + 2] == "<<":
            result.append("<")
            i += 2
            continue
        if i < len(txt) - 1 and txt[i : i + 2] == ">>":
            result.append(">")
            i += 2
            continue

        # Handle color tags
        if txt[i] == "<":
            # Check if it's a closing tag
            if i < len(txt) - 1 and txt[i + 1] == "/":
                end = txt.find(">", i)
                if end != -1 and txt[i + 2 : end] in color_map:
                    result.append(Fore.RESET)
                    i = end + 1
                    continue
            # Check if it's an opening tag
            end = txt.find(">", i)
            if end != -1 and txt[i + 1 : end] in color_map:
                result.append(color_map[txt[i + 1 : end]])
                i = end + 1
                continue

        # Regular character
        result.append(txt[i])
        i += 1

    return "".join(result)


def write(txt: str = "", file: TextIO = stdout, end: str = "", *, flush: bool = False) -> None:
    if not txt:
        return
    print(_parse_style(txt), file=file, end=end, flush=flush)


def writeln(txt: str = "", file: TextIO = stdout, end: str = "\n", *, flush: bool = False) -> None:
    if not txt:
        print()
        return
    print(f"{_parse_style(txt)}", file=file, end=end, flush=flush)


def perr(msg: str, exit_code: ExitCode | None = None, *, prefix: bool = True, end: str = "\n") -> None:
    if prefix:
        write("*<red>error:</red>* ", file=stderr)

    writeln(msg, file=stderr, end=end)

    if exit_code is not None:
        sexit(exit_code.value)


def pwarn(msg: str, *, prefix: bool = True, end: str = "\n") -> None:
    if prefix:
        write("<ylw>*warning:*</ylw> ")

    writeln(msg, end=end)


def yn_input(prompt: str, *, strict: bool = False) -> bool:
    pos = {"yes", "y", "yeah", "yea", "ye"}
    neg = {"no", "n", "nope"}

    while True:
        inp = input(prompt).lower()

        if inp in pos:
            return True

        if inp in neg:
            return False

        if not strict:
            return False

        perr("invalid input (enter 'y'/'yes' or 'n'/'no')")
